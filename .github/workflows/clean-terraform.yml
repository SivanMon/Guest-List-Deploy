name: Guest List Clean Terraform (Deploy)

on:
  workflow_dispatch:
    inputs:
      action:
        description: What to run
        type: choice
        required: true
        default: plan
        options: [plan, apply, destroy]
      environment:
        description: Environment / student
        type: choice
        required: true
        default: dev
        options: [sivan, dvir, gili, sahar, dev, main]
  repository_dispatch:
    types: [deploy_plan, deploy_apply]

  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, ready_for_review]

env:
  TF_VERSION: 1.9.8
  TF_CLI_ARGS: -no-color
  AWS_REGION: us-east-1

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.setvars.outputs.environment }}
      namespace: ${{ steps.setvars.outputs.namespace }}
      tf_state_bucket: ${{ steps.setvars.outputs.tf_state_bucket }}
      tf_state_key: ${{ steps.setvars.outputs.tf_state_key }}
      image_repo: ${{ steps.setvars.outputs.image_repo }}
      image_tag_prefix: ${{ steps.setvars.outputs.image_tag_prefix }}
    steps:
      - name: Decide environment/namespace/state layout
        id: setvars
        shell: bash
        env:
          EVENT_NAME:   ${{ github.event_name }}
          DISPATCH_ENV: ${{ github.event.client_payload.environment }}
          INPUT_ENV:    ${{ inputs.environment }}
          AWS_REGION:   ${{ env.AWS_REGION }}
          REPO_OWNER:   ${{ github.repository_owner }}
          REPO:         ${{ github.repository }}   # e.g. SivanMon/Guest-List-Deploy
        run: |
          set -euo pipefail

          # 1) Resolve environment
          if [[ "${EVENT_NAME}" == "repository_dispatch" && -n "${DISPATCH_ENV:-}" ]]; then
            ENVIRONMENT="${DISPATCH_ENV}"
          else
            ENVIRONMENT="${INPUT_ENV:-dev}"
          fi

          NAMESPACE="guestlist"

          # 2) Globally-unique bucket use owner+repo
          owner="$(echo "${REPO_OWNER}" | tr '[:upper:]' '[:lower:]' | tr -cd 'a-z0-9-')"
          repo="$(echo "${REPO#*/}"  | tr '[:upper:]' '[:lower:]' | tr -cd 'a-z0-9-')"
          actor="$(echo "${GITHUB_ACTOR}" | tr '[:upper:]' '[:lower:]' | tr -cd 'a-z0-9-')"
          bucket="guestlist-tfstate-${owner}-${repo}-${actor}"
          bucket="${bucket:0:63}"               # S3 bucket length limit
          bucket="${bucket%-}"                  # strip trailing '-'
          TF_STATE_BUCKET="${bucket}"

          # Per-environment key
          TF_STATE_KEY="envs/${ENVIRONMENT}/terraform.tfstate"

          # 3) Image repo + tag prefix
          IMAGE_REPO="sivanmonshi/guestlistapi"
          case "${ENVIRONMENT}" in
            sivan|dvir|sahar|gili) IMAGE_TAG_PREFIX="${ENVIRONMENT}-feature-" ;;
            dev)                    IMAGE_TAG_PREFIX="dev" ;;
            main)                   IMAGE_TAG_PREFIX="latest" ;;
            *)                      IMAGE_TAG_PREFIX="dev" ;;
          esac

          {
            echo "environment=${ENVIRONMENT}"
            echo "namespace=${NAMESPACE}"
            echo "tf_state_bucket=${TF_STATE_BUCKET}"
            echo "tf_state_key=${TF_STATE_KEY}"
            echo "image_repo=${IMAGE_REPO}"
            echo "image_tag_prefix=${IMAGE_TAG_PREFIX}"
          } >> "$GITHUB_OUTPUT"

          # Export to job env so downstream steps that rely on env vars keep working
          echo "TF_STATE_BUCKET=${TF_STATE_BUCKET}" >> "$GITHUB_ENV"
          echo "TF_STATE_KEY=${TF_STATE_KEY}"       >> "$GITHUB_ENV"

      - name: Prefer immutable dev-SHA tag for manual dev runs
        if: ${{ github.event_name == 'workflow_dispatch' && steps.setvars.outputs.environment == 'dev' }}
        id: pin_dev_sha
        shell: bash
        run: |
          set -euo pipefail
          TAG="$(
            curl -fsSL 'https://hub.docker.com/v2/repositories/sivanmonshi/guestlistapi/tags?page_size=100&ordering=last_updated' \
            | python3 -c 'import sys,json; d=json.load(sys.stdin); print(next((r.get("name","") for r in d.get("results",[]) if r.get("name","").startswith("dev-")), ""))'
          )"
          if [[ -n "$TAG" ]]; then
            echo "Using immutable tag: $TAG"
            echo "IMAGE_TAG_PREFIX=$TAG" >> "$GITHUB_ENV"
            echo "image_tag_prefix=$TAG" >> "$GITHUB_OUTPUT"
          else
            echo "No dev-* tag found; falling back to :dev"
          fi

      - name: Show resolved values
        run: |
          echo "ENVIRONMENT:      ${{ steps.setvars.outputs.environment }}"
          echo "NAMESPACE:        ${{ steps.setvars.outputs.namespace }}"
          echo "TF_STATE_BUCKET:  ${{ steps.setvars.outputs.tf_state_bucket }}"
          echo "TF_STATE_KEY:     ${{ steps.setvars.outputs.tf_state_key }}"
          echo "IMAGE_REPO:       ${{ steps.setvars.outputs.image_repo }}"
          echo "IMAGE_TAG_PREFIX: ${{ steps.setvars.outputs.image_tag_prefix }}"

  configure-environment:
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-environment.outputs.environment }}
    needs: determine-environment
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      TF_STATE_BUCKET: ${{ needs.determine-environment.outputs.tf_state_bucket }}
    steps:

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Ensure S3 state bucket exists (idempotent)
        shell: bash
        env:
          B: ${{ env.TF_STATE_BUCKET }}   # comes from job env set earlier (or from needs.outputs if you set it there)
          R: ${{ env.AWS_REGION }}
        run: |
          set -euo pipefail
          echo "Ensuring bucket: ${B} in region: ${R}"

          if aws s3api head-bucket --bucket "${B}" 2>/dev/null; then
            echo "Bucket ${B} exists."
          else
            if [[ "${R}" == "us-east-1" ]]; then
              aws s3api create-bucket --bucket "${B}"
            else
              aws s3api create-bucket --bucket "${B}" \
                --create-bucket-configuration LocationConstraint="${R}"
            fi
            aws s3api put-bucket-versioning --bucket "${B}" --versioning-configuration Status=Enabled
            aws s3api put-bucket-encryption --bucket "${B}" \
              --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}'
            aws s3api put-public-access-block --bucket "${B}" \
              --public-access-block-configuration BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true
          fi

      - name: Ensure DynamoDB lock table exists (idempotent)
        shell: bash
        run: |
          set -euo pipefail
          T="terraform-locks"
          if aws dynamodb describe-table --table-name "$T" >/dev/null 2>&1; then
            echo "DynamoDB table $T exists."
          else
            aws dynamodb create-table \
              --table-name "$T" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name "$T"
          fi

  terraform:
    runs-on: ubuntu-latest
    needs: [determine-environment, configure-environment]
    environment: ${{ needs.determine-environment.outputs.environment }}
    env:
      ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
      NAMESPACE: ${{ needs.determine-environment.outputs.namespace }}
      TF_STATE_BUCKET: ${{ needs.determine-environment.outputs.tf_state_bucket }}
      TF_STATE_KEY: ${{ needs.determine-environment.outputs.tf_state_key }}
      IMAGE_REPO: ${{ needs.determine-environment.outputs.image_repo }}
      IMAGE_TAG_PREFIX: ${{ needs.determine-environment.outputs.image_tag_prefix }}
      TF_VAR_state_bucket_name: ${{ needs.determine-environment.outputs.tf_state_bucket }}
      TF_VAR_cluster_role_name: guestlist-cluster-cluster-role
      TF_VAR_node_group_role_name: guestlist-cluster-node-group-role
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Resolve image tag (and print selection)
        id: imagetag
        shell: bash
        run: |
          set -euo pipefail
          repo="${IMAGE_REPO}"
          prefix="${IMAGE_TAG_PREFIX}"
          tag=""

          if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" && "${ENVIRONMENT}" == "dev" ]]; then
            latest="$(curl -fsSL "https://hub.docker.com/v2/repositories/${repo}/tags?page_size=100&ordering=last_updated" \
              | jq -r '.results[].name' | grep '^dev-' | head -n1)"
            if [[ -n "${latest}" ]]; then
              prefix="${latest}"
            fi
          fi
          case "${ENVIRONMENT}" in
            sivan|dvir|sahar|gili)
              # Latest tag that starts with "<student>-feature-"
              tag="$(curl -fsSL "https://hub.docker.com/v2/repositories/${repo}/tags?page_size=100" \
                | jq -r '.results[] | select(.name | startswith("'"${prefix}"'")) | .name' | head -n1)"
              ;;
            dev|main)
              tag="${prefix}"
              ;;
            *)
              tag="dev"
              ;;
          esac

          if [[ -z "${tag}" ]]; then
            echo "Failed to resolve image tag for ${ENVIRONMENT}" >&2
            exit 1
          fi

          echo "image_tag=${tag}" >> "$GITHUB_OUTPUT"
          echo "Using image: ${repo}:${tag}"
          echo "Docker pull hint: docker pull ${repo}:${tag}"

      - name: Terraform Init (remote state)
        shell: bash
        run: |
          set -euo pipefail
          terraform init -input=false -reconfigure \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=terraform-locks"

      - name: Terraform Plan
        if: ${{ (github.event_name == 'repository_dispatch' && github.event.action == 'deploy_plan') || (github.event_name == 'workflow_dispatch' && inputs.action == 'plan') }}
        shell: bash
        run: |
          set -euo pipefail
          terraform plan -input=false \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=${{ steps.imagetag.outputs.image_tag }}" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -out=tfplan-${ENVIRONMENT}

      - name: Terraform Apply
        if: ${{ (github.event_name == 'repository_dispatch' && github.event.action == 'deploy_apply') || (github.event_name == 'workflow_dispatch' && inputs.action == 'apply') }}
        shell: bash
        run: |
          set -euo pipefail
          # If a plan exists from the previous step, use it; otherwise apply directly (push on main path).
          if [[ -f "tfplan-${ENVIRONMENT}" ]]; then
            terraform apply -input=false -auto-approve "tfplan-${ENVIRONMENT}"
          else
            terraform apply -input=false -auto-approve \
              -var="environment=${ENVIRONMENT}" \
              -var="aws_region=${AWS_REGION}" \
              -var="namespace=${NAMESPACE}" \
              -var="image_tag=${{ steps.imagetag.outputs.image_tag }}" \
              -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
              -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          fi

      - name: Show LB URL & health check (port 9999, wait)
        if: ${{ (github.event_name == 'repository_dispatch' && github.event.action == 'deploy_apply') || (github.event_name == 'workflow_dispatch' && inputs.action == 'apply') }}
        shell: bash
        run: |
          set -euo pipefail

          # Try to read IP first; if empty, use hostname
          LB="$(terraform output -raw load_balancer_ip 2>/dev/null || true)"
          USE_DNS=0
          if [[ -z "${LB}" ]]; then
            LB="$(terraform output -raw load_balancer_hostname 2>/dev/null || true)"
            USE_DNS=1
          fi

          if [[ -z "${LB}" ]]; then
            echo "Failed to read Terraform output 'load_balancer_ip' or 'load_balancer_hostname'."
            exit 1
          fi

          PORT=9999
          BASE_URL="http://${LB}:${PORT}"
          echo "Load Balancer target: ${BASE_URL}"

          # If hostname, wait for DNS to resolve
          if [[ "${USE_DNS}" -eq 1 ]]; then
            echo "Waiting for DNS to resolve for ${LB}..."
            for i in {1..120}; do
              if getent hosts "${LB}" >/dev/null 2>&1; then
                echo "DNS resolved on attempt #${i}"
                break
              fi
              sleep 5
              [[ $i -eq 120 ]] && { echo "Timed out waiting for DNS (${LB})"; exit 1; }
            done
          fi

          # Health polling: try /healthz then /
          ATTEMPTS=30
          SLEEP=10
          for i in $(seq 1 $ATTEMPTS); do
            CODE="$(curl -sS -m 5 -o /dev/null -w '%{http_code}' "${BASE_URL}/healthz" || echo "000")"
            if [[ "$CODE" -ge 200 && "$CODE" -lt 400 ]]; then
              echo "OK: HTTP $CODE from ${BASE_URL}/healthz"
              exit 0
            fi
            CODE_ROOT="$(curl -sS -m 5 -o /dev/null -w '%{http_code}' "${BASE_URL}/" || echo "000")"
            if [[ "$CODE_ROOT" -ge 200 && "$CODE_ROOT" -lt 400 ]]; then
              echo "OK: HTTP $CODE_ROOT from ${BASE_URL}/"
              exit 0
            fi
            echo "Attempt $i/$ATTEMPTS: healthz=$CODE root=$CODE_ROOT — retrying in ${SLEEP}s..."
            sleep $SLEEP
          done

          echo "ERROR: Service not healthy after $((ATTEMPTS*SLEEP))s at ${BASE_URL}"
          exit 1

      - name: Terraform Destroy
        if: ${{ github.event_name == 'workflow_dispatch' && inputs.action == 'destroy' }}
        shell: bash
        run: |
          set -euo pipefail
          terraform destroy -input=false -auto-approve \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=ignore" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}"