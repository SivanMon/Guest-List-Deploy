name: Guest List Clean Terraform (Deploy)

on:
  workflow_dispatch:
    inputs:
      action:
        description: plan / apply / destroy
        type: choice
        required: true
        default: plan
        options: [plan, apply, destroy]
      env:
        description: Environment name (dev/staging/main or student name). Leave empty to derive from branch.
        required: false
        default: ""
      branch:
        description: Branch to run on (defaults to current)
        required: false
        default: ""
      image_tag:
        description: "Image tag to deploy (defaults: <env>-feature on feature branches, otherwise latest)"
        required: false
        default: ""
  push:
    branches:
      - main

env:
  TF_VERSION: 1.9.8
  TF_CLI_ARGS: -no-color
  AWS_REGION: us-east-1

jobs:
  pick:
    runs-on: ubuntu-latest
    outputs:
      env: ${{ steps.pick.outputs.env }}
      branch: ${{ steps.pick.outputs.branch }}
      action: ${{ steps.pick.outputs.action }}
      image_tag: ${{ steps.pick.outputs.image_tag }}
      state_bucket: ${{ steps.pick.outputs.state_bucket }}
      state_key: ${{ steps.pick.outputs.state_key }}
      is_feature: ${{ steps.pick.outputs.is_feature }}
    steps:
      - id: pick
        shell: bash
        run: |
          set -euo pipefail

          BRANCH="${{ github.event.inputs.branch || '' }}"
          if [ -z "$BRANCH" ]; then BRANCH="${GITHUB_REF_NAME}"; fi

          ACTION="${{ github.event.inputs.action || 'plan' }}"

          # env from input or derived from branch
          ENV_IN="${{ github.event.inputs.env || '' }}"
          if [ -n "$ENV_IN" ]; then
            ENV="$ENV_IN"
          else
            if [[ "$BRANCH" == *-feature ]]; then
              ENV="${BRANCH%-feature}"
            else
              ENV="dev"
            fi
          fi

          if [[ "$BRANCH" == *-feature ]]; then
            IS_FEATURE=1
            BUCKET="guestlist-tfstate-${ENV}-feature"
          else
            IS_FEATURE=0
            BUCKET="guestlist-tfstate-${ENV}"
          fi
          KEY="envs/${ENV}/terraform.tfstate"

          IMG_IN="${{ github.event.inputs.image_tag || '' }}"
          if [ -n "$IMG_IN" ]; then
            IMG="$IMG_IN"
          else
            if [ "$IS_FEATURE" = "1" ]; then IMG="${ENV}-feature"; else IMG="latest"; fi
          fi

          echo "env=$ENV" >> "$GITHUB_OUTPUT"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"
          echo "action=$ACTION" >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMG" >> "$GITHUB_OUTPUT"
          echo "state_bucket=$BUCKET" >> "$GITHUB_OUTPUT"
          echo "state_key=$KEY" >> "$GITHUB_OUTPUT"
          echo "is_feature=$IS_FEATURE" >> "$GITHUB_OUTPUT"

  tf:
    needs: pick
    runs-on: ubuntu-latest
    # Binds to a GitHub Environment with the same name if you ever add it (optional)
    environment: ${{ needs.pick.outputs.env }}
    env:
      AWS_REGION: ${{ env.AWS_REGION }}
      ENVIRONMENT: ${{ needs.pick.outputs.env }}
      TF_STATE_BUCKET: ${{ needs.pick.outputs.state_bucket }}
      TF_STATE_KEY: ${{ needs.pick.outputs.state_key }}
      IMAGE_TAG: ${{ needs.pick.outputs.image_tag }}
      NAMESPACE: guestlist
      STUDENT_NAME: ${{ needs.pick.outputs.env }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.pick.outputs.branch }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Ensure state backend (S3 & DynamoDB)
        shell: bash
        run: |
          set -euo pipefail
          BKT="${TF_STATE_BUCKET}"
          KEY="${TF_STATE_KEY}"
          TBL="terraform-locks"

          if ! aws s3api head-bucket --bucket "$BKT" 2>/dev/null; then
            aws s3api create-bucket --bucket "$BKT" --region "${AWS_REGION}" --create-bucket-configuration LocationConstraint="${AWS_REGION}" || true
          fi
          aws s3api put-bucket-versioning --bucket "$BKT" --versioning-configuration Status=Enabled || true
          aws s3api put-bucket-encryption --bucket "$BKT" \
            --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}' || true

          if ! aws dynamodb describe-table --table-name "$TBL" >/dev/null 2>&1; then
            aws dynamodb create-table \
              --table-name "$TBL" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name "$TBL"
          fi

      - name: Terraform init
        shell: bash
        run: |
          set -euo pipefail
          terraform init -input=false -reconfigure \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=terraform-locks"

      - name: Terraform Plan
        if: ${{ needs.pick.outputs.action == 'plan' }}
        shell: bash
        run: |
          set -euo pipefail
          terraform plan -lock-timeout=60s -parallelism=7 -input=false -no-color \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=${IMAGE_TAG}" \
            -var="student_name=${STUDENT_NAME}" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -out="tfplan-${ENVIRONMENT}"

      - name: Terraform Apply
        if: ${{ needs.pick.outputs.action == 'apply' }}
        shell: bash
        run: |
          set -euo pipefail
          terraform plan -lock-timeout=60s -parallelism=7 -input=false -no-color \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=${IMAGE_TAG}" \
            -var="student_name=${STUDENT_NAME}" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -out="tfplan-${ENVIRONMENT}"

          terraform apply -input=false -auto-approve "tfplan-${ENVIRONMENT}"

      - name: Show LB URL and health check
        if: ${{ needs.pick.outputs.action == 'apply' }}
        shell: bash
        run: |
          set -euo pipefail
          # If your outputs.tf exposes the cluster name, try to read it; fallback to known name
          CN="$(terraform output -raw cluster_name 2>/dev/null || true)"
          if [ -z "$CN" ]; then CN="guestlist-cluster"; fi

          aws eks update-kubeconfig --name "$CN" --region "${AWS_REGION}"

          # Grab LB hostname from the service
          SVC_HOST="$(kubectl -n ${NAMESPACE} get svc -l app=guestlist-api -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)"
          echo "LoadBalancer: ${SVC_HOST}"

          for p in /readyz /healthz /; do
            echo "--- curl http://${SVC_HOST}${p}"
            (curl -fsS "http://${SVC_HOST}${p}" || true)
            echo
          done

      - name: Terraform Destroy
        if: ${{ needs.pick.outputs.action == 'destroy' }}
        shell: bash
        run: |
          set -euo pipefail
          terraform destroy -input=false -auto-approve \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=ignore" \
            -var="student_name=${STUDENT_NAME}" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}"
