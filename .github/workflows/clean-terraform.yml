name: Terraform

on:
  workflow_dispatch:
    inputs:
      action:
        description: What to do
        type: choice
        required: true
        default: plan
        options: [plan, apply, destroy]
      environment:
        description: Target env (student or dev/staging/main) or 'auto' to infer from branch
        type: choice
        required: true
        default: dev
        options: [auto, dev, staging, main, sivan, dvir, sahar, gili]
      ref:
        description: Git ref to run (branch/tag). Empty = current ref.
        type: string
        required: false
        default: ''
      aws_region:
        description: AWS region for CLI and backend
        type: string
        required: true
        default: us-east-1
      image_tag_override:
        description: Optional exact image tag (e.g. sivan-feature-abc1234)
        type: string
        required: false
        default: ''

permissions:
  contents: read

env:
  TF_VERSION: 1.9.8
  TF_CLI_ARGS: -no-color

jobs:
  decide:
    runs-on: ubuntu-latest
    outputs:
      env:        ${{ steps.pick.outputs.env }}
      ref:        ${{ steps.pick.outputs.ref }}
      region:     ${{ steps.pick.outputs.region }}
      image_tag:  ${{ steps.pick.outputs.image_tag }}
      state_key:  ${{ steps.pick.outputs.state_key }}
      bucket:     ${{ steps.pick.outputs.bucket }}
      aki_key:    ${{ steps.pick.outputs.aki_key }}
      sak_key:    ${{ steps.pick.outputs.sak_key }}
    steps:
      - name: Decide env, ref, image, state, secret names
        id: pick
        run: |
          set -euo pipefail
          IN_ENV="${{ github.event.inputs.environment }}"
          REF="${{ github.event.inputs.ref || github.ref }}"
          REGION="${{ github.event.inputs.aws_region }}"

          # Take last segment of branch name (handles refs like feature/foo-feature)
          BR="${{ github.ref_name }}"
          BASE="${BR##*/}"
          LOWER_BASE="$(echo "$BASE" | tr '[:upper:]' '[:lower:]')"

          if [ "$IN_ENV" = "auto" ]; then
            if [[ "$LOWER_BASE" == *-feature ]]; then
              ENV="${LOWER_BASE%-feature}"
            else
              case "$LOWER_BASE" in
                main)    ENV="main" ;;
                staging) ENV="staging" ;;
                dev|development) ENV="dev" ;;
                *)       ENV="dev" ;;   # default fallback
              esac
            fi
          else
            ENV="$(echo "$IN_ENV" | tr '[:upper:]' '[:lower:]')"
          fi

          # image tag: allow override; otherwise follow your convention
          if [ -n "${{ github.event.inputs.image_tag_override }}" ]; then
            IMAGE="${{ github.event.inputs.image_tag_override }}"
          else
            if [[ "$LOWER_BASE" == *-feature ]]; then
              IMAGE="${ENV}-feature"     # your API adds -<sha> itself
            else
              case "$ENV" in
                dev)     IMAGE="dev" ;;
                staging) IMAGE="staging" ;;
                main)    IMAGE="latest" ;;
                *)       IMAGE="${ENV}-feature" ;;
              esac
            fi
          fi

          # backend bucket/key (keep your existing naming)
          if [[ "$LOWER_BASE" == *-feature ]]; then
            BUCKET="guestlist-tfstate-${ENV}-feature"
          else
            BUCKET="guestlist-tfstate-${ENV}"
          fi
          STATE_KEY="envs/${ENV}/terraform.tfstate"

          # dynamic secret names (uppercased ENV)
          ENV_UPPER=$(echo "$ENV" | tr '[:lower:]' '[:upper:]')

          echo "env=${ENV}"             >> "$GITHUB_OUTPUT"
          echo "ref=${REF}"             >> "$GITHUB_OUTPUT"
          echo "region=${REGION}"       >> "$GITHUB_OUTPUT"
          echo "image_tag=${IMAGE}"     >> "$GITHUB_OUTPUT"
          echo "bucket=${BUCKET}"       >> "$GITHUB_OUTPUT"
          echo "state_key=${STATE_KEY}" >> "$GITHUB_OUTPUT"
          echo "aki_key=AWS_ACCESS_KEY_ID_${ENV_UPPER}"     >> "$GITHUB_OUTPUT"
          echo "sak_key=AWS_SECRET_ACCESS_KEY_${ENV_UPPER}" >> "$GITHUB_OUTPUT"

          echo "ENV=$ENV"
          echo "BRANCH=$BR"
          echo "BUCKET=$BUCKET"
          echo "STATE_KEY=$STATE_KEY"
          echo "IMAGE=$IMAGE"
          echo "AKI_KEY=AWS_ACCESS_KEY_ID_${ENV_UPPER}"
          echo "SAK_KEY=AWS_SECRET_ACCESS_KEY_${ENV_UPPER}"


  terraform:
    needs: decide
    runs-on: ubuntu-latest
    timeout-minutes: 90
    concurrency:
      group: tf-${{ needs.decide.outputs.env }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.decide.outputs.ref }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Check required secrets exist for this env
        env:
          AKI: ${{ secrets[needs.decide.outputs.aki_key] }}
          SAK: ${{ secrets[needs.decide.outputs.sak_key] }}
        run: |
          set -euo pipefail
          if [ -z "${AKI:-}" ] || [ -z "${SAK:-}" ]; then
            echo "::error::Missing repo secrets for env '${{ needs.decide.outputs.env }}'."
            echo "::error::Create BOTH secrets with these exact names in Settings > Secrets > Actions:"
            echo "::error::  ${{ needs.decide.outputs.aki_key }}"
            echo "::error::  ${{ needs.decide.outputs.sak_key }}"
            exit 1
          fi

      - name: Configure AWS credentials (from repo secrets per env)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets[needs.decide.outputs.aki_key] }}
          aws-secret-access-key: ${{ secrets[needs.decide.outputs.sak_key] }}
          aws-region:            ${{ needs.decide.outputs.region }}

      - name: Ensure S3 bucket (state) exists
        run: |
          set -euo pipefail
          B="${{ needs.decide.outputs.bucket }}"
          R="${{ needs.decide.outputs.region }}"
          if aws s3api head-bucket --bucket "$B" 2>/dev/null; then
            echo "Bucket $B exists"
          else
            if [ "$R" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$B"
            else
              aws s3api create-bucket --bucket "$B" \
                --create-bucket-configuration LocationConstraint="$R"
            fi
            aws s3api put-bucket-versioning --bucket "$B" --versioning-configuration Status=Enabled
            echo "Created bucket $B"
          fi

      - name: Ensure DynamoDB lock table exists
        run: |
          set -euo pipefail
          T="terraform-locks"
          if aws dynamodb describe-table --table-name "$T" >/dev/null 2>&1; then
            echo "DDB table $T exists"
          else
            aws dynamodb create-table \
              --table-name "$T" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name "$T"
            echo "Created DDB table $T"
          fi

      - name: Terraform init (reconfigure backend)
        run: |
          set -euo pipefail
          terraform init -input=false -reconfigure \
            -backend-config="bucket=${{ needs.decide.outputs.bucket }}" \
            -backend-config="key=${{ needs.decide.outputs.state_key }}" \
            -backend-config="region=${{ needs.decide.outputs.region }}" \
            -backend-config="dynamodb_table=terraform-locks"

      - name: Terraform validate
        run: terraform validate

      # ---------- PLAN ----------
      - name: Terraform plan
        if: ${{ github.event.inputs.action == 'plan' }}
        run: |
          set -euo pipefail
          terraform plan -input=false \
            -lock-timeout=60s \
            -var="environment=${{ needs.decide.outputs.env }}" \
            -var="aws_region=${{ needs.decide.outputs.region }}" \
            -var="namespace=guestlist" \
            -var="image_tag=${{ needs.decide.outputs.image_tag }}" \
            -var="aws_access_key_id=${{ secrets[needs.decide.outputs.aki_key] }}" \
            -var="aws_secret_access_key=${{ secrets[needs.decide.outputs.sak_key] }}"

      # ---------- APPLY ----------
      - name: Terraform apply
        if: ${{ github.event.inputs.action == 'apply' }}
        run: |
          set -euo pipefail
          terraform apply -input=false -auto-approve \
            -lock-timeout=60s \
            -var="environment=${{ needs.decide.outputs.env }}" \
            -var="aws_region=${{ needs.decide.outputs.region }}" \
            -var="namespace=guestlist" \
            -var="image_tag=${{ needs.decide.outputs.image_tag }}" \
            -var="aws_access_key_id=${{ secrets[needs.decide.outputs.aki_key] }}" \
            -var="aws_secret_access_key=${{ secrets[needs.decide.outputs.sak_key] }}"

      - name: Fetch cluster name from state (after apply)
        if: ${{ github.event.inputs.action == 'apply' }}
        id: cluster
        run: |
          set -euo pipefail
          C="$(terraform output -raw cluster_name 2>/dev/null || true)"
          [ -z "$C" ] && C="guestlist-cluster"
          echo "name=$C" >> "$GITHUB_OUTPUT"

      - name: Show LB URL and health check
        if: ${{ github.event.inputs.action == 'apply' }}
        run: |
          set -euo pipefail
          aws eks update-kubeconfig --name "${{ steps.cluster.outputs.name }}" --region "${{ needs.decide.outputs.region }}"
          EXTERNAL="$(kubectl -n guestlist get svc guestlist-service -o jsonpath='{.status.loadBalancer.ingress[0].hostname}{.status.loadBalancer.ingress[0].ip}')"
          echo "LB: http://$EXTERNAL:1111"
          curl -fsS "http://$EXTERNAL:1111/healthz"
          curl -fsS "http://$EXTERNAL:1111/readyz"

      # ---------- DESTROY ----------
      - name: Terraform destroy
        if: ${{ github.event.inputs.action == 'destroy' }}
        run: |
          set -euo pipefail
          terraform destroy -input=false -auto-approve \
            -lock-timeout=60s \
            -var="environment=${{ needs.decide.outputs.env }}" \
            -var="aws_region=${{ needs.decide.outputs.region }}" \
            -var="namespace=guestlist" \
            -var="image_tag=ignore" \
            -var="aws_access_key_id=${{ secrets[needs.decide.outputs.aki_key] }}" \
            -var="aws_secret_access_key=${{ secrets[needs.decide.outputs.sak_key] }}"
