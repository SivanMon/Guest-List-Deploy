name: Guest List Clean Terraform (Deploy)

on:
  workflow_dispatch:
    inputs:
      action:
        description: plan / apply / destroy
        required: true
        default: plan
        type: choice
        options: [plan, apply, destroy]
      environment:
        description: Environment/student (e.g. sivan, dvir, sahar, gili, dev, staging, main). Leave empty to derive from branch (for *-feature).
        required: false
        default: ""
      region:
        description: AWS region
        required: true
        default: us-east-1
      namespace:
        description: Kubernetes namespace
        required: true
        default: guestlist
      image_tag_override:
        description: Optional exact image tag (e.g. sivan-feature-780356c). If empty uses <env>-feature or latest for main.
        required: false
        default: ""
      cluster_name:
        description: EKS cluster name for kubectl (used by LB check). If empty uses guestlist-cluster.
        required: false
        default: ""
  push:
    branches:
      - "*-feature"

permissions:
  contents: read
  id-token: write

jobs:
  pick:
    runs-on: ubuntu-latest
    outputs:
      action: ${{ steps.pick.outputs.action }}
      env: ${{ steps.pick.outputs.env }}
      region: ${{ steps.pick.outputs.region }}
      namespace: ${{ steps.pick.outputs.namespace }}
      cluster_name: ${{ steps.pick.outputs.cluster_name }}
      state_bucket: ${{ steps.pick.outputs.state_bucket }}
      state_key: ${{ steps.pick.outputs.state_key }}
      image_tag_default: ${{ steps.pick.outputs.image_tag_default }}
      aki_key: ${{ steps.pick.outputs.aki_key }}
      sak_key: ${{ steps.pick.outputs.sak_key }}
    steps:
      - name: Decide inputs
        id: pick
        run: |
          set -euo pipefail

          # Inputs or defaults
          ACTION="${{ github.event_name == 'workflow_dispatch' && inputs.action || 'plan' }}"
          REGION="${{ github.event_name == 'workflow_dispatch' && inputs.region || 'us-east-1' }}"
          NAMESPACE="${{ github.event_name == 'workflow_dispatch' && inputs.namespace || 'guestlist' }}"
          CLUSTER_NAME_IN="${{ github.event_name == 'workflow_dispatch' && inputs.cluster_name || '' }}"
          # Resolve env: manual input wins; else derive from branch pattern "<name>-feature"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ inputs.environment }}" ]; then
            ENV="${{ inputs.environment }}"
          else
            BRANCH="${{ github.ref_name }}"
            # Derive "sivan" from "sivan-feature", etc. If no match, default "dev".
            if echo "$BRANCH" | grep -Eiq '^[a-z0-9-]+-feature$'; then
              ENV="${BRANCH%-feature}"
            else
              ENV="dev"
            fi
          fi

          # State layout: bucket per student env, single table shared
          STATE_BUCKET="guestlist-tfstate-${ENV}-feature"
          STATE_KEY="envs/${ENV}/terraform.tfstate"

          # Image tag rule:
          # - if main -> latest
          # - else use <env>-feature (moving tag). Can override via input on dispatch.
          if [ "$ENV" = "main" ]; then
            IMAGE_TAG_DEFAULT="latest"
          else
            IMAGE_TAG_DEFAULT="${ENV}-feature"
          fi

          # Cluster name default
          CLUSTER_NAME="${CLUSTER_NAME_IN:-guestlist-cluster}"

          # If you later want env-specific secrets (optional), these are the expected names
          echo "aki_key=AWS_ACCESS_KEY_ID_${ENV^^}" >>"$GITHUB_OUTPUT"
          echo "sak_key=AWS_SECRET_ACCESS_KEY_${ENV^^}" >>"$GITHUB_OUTPUT"

          echo "action=$ACTION" >>"$GITHUB_OUTPUT"
          echo "env=$ENV" >>"$GITHUB_OUTPUT"
          echo "region=$REGION" >>"$GITHUB_OUTPUT"
          echo "namespace=$NAMESPACE" >>"$GITHUB_OUTPUT"
          echo "cluster_name=$CLUSTER_NAME" >>"$GITHUB_OUTPUT"
          echo "state_bucket=$STATE_BUCKET" >>"$GITHUB_OUTPUT"
          echo "state_key=$STATE_KEY" >>"$GITHUB_OUTPUT"
          echo "image_tag_default=$IMAGE_TAG_DEFAULT" >>"$GITHUB_OUTPUT"

  tf:
    needs: pick
    runs-on: ubuntu-latest
    env:
      TF_CLI_ARGS: -no-color
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Resolve creds: env-suffixed secrets first; fallback to generic
      - name: Resolve AWS creds
        id: awscreds
        env:
          AKI_SUFFIXED: ${{ secrets[needs.pick.outputs.aki_key] }}
          SAK_SUFFIXED: ${{ secrets[needs.pick.outputs.sak_key] }}
          AKI_GENERIC:  ${{ secrets.AWS_ACCESS_KEY_ID }}
          SAK_GENERIC:  ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          set -euo pipefail
          AKI="${AKI_SUFFIXED:-}"; SAK="${SAK_SUFFIXED:-}"
          if [ -z "$AKI" ] || [ -z "$SAK" ]; then
            AKI="${AKI_GENERIC:-}"; SAK="${SAK_GENERIC:-}"
          fi
          if [ -z "$AKI" ] || [ -z "$SAK" ]; then
            echo "::error::Missing AWS credentials. Define either env-specific secrets (${ {needs.pick.outputs.aki_key} }, ${ {needs.pick.outputs.sak_key} }) or generic AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY."
            exit 1
          fi
          echo "aki=$AKI" >> "$GITHUB_OUTPUT"
          echo "sak=$SAK" >> "$GITHUB_OUTPUT"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ steps.awscreds.outputs.aki }}
          aws-secret-access-key: ${{ steps.awscreds.outputs.sak }}
          aws-region:            ${{ needs.pick.outputs.region }}

      # Create backend bucket + lock table if missing (idempotent)
      - name: Ensure S3 state bucket and DynamoDB lock table exist
        run: |
          set -euo pipefail
          BUCKET="${{ needs.pick.outputs.state_bucket }}"
          REGION="${{ needs.pick.outputs.region }}"
          LOCK_TABLE="terraform-locks"

          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            aws s3api create-bucket --bucket "$BUCKET" --region "$REGION" \
              --create-bucket-configuration LocationConstraint="$REGION"
            aws s3api put-bucket-versioning --bucket "$BUCKET" --versioning-configuration Status=Enabled
          fi

          if ! aws dynamodb describe-table --table-name "$LOCK_TABLE" >/dev/null 2>&1; then
            aws dynamodb create-table \
              --table-name "$LOCK_TABLE" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            # Wait until ACTIVE
            aws dynamodb wait table-exists --table-name "$LOCK_TABLE"
          fi

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.8

      - name: Terraform Init (remote state)
        run: |
          terraform init -input=false -reconfigure \
            -backend-config="bucket=${{ needs.pick.outputs.state_bucket }}" \
            -backend-config="key=${{ needs.pick.outputs.state_key }}" \
            -backend-config="region=${{ needs.pick.outputs.region }}" \
            -backend-config="dynamodb_table=terraform-locks"

      # Pick image tag: override if provided on dispatch; otherwise default rule
      - name: Compute image tag
        id: img
        run: |
          set -euo pipefail
          TAG_IN="${{ github.event_name == 'workflow_dispatch' && inputs.image_tag_override || '' }}"
          if [ -n "$TAG_IN" ]; then
            echo "tag=$TAG_IN" >> "$GITHUB_OUTPUT"
          else
            echo "tag=${{ needs.pick.outputs.image_tag_default }}" >> "$GITHUB_OUTPUT"
          fi
          echo "Using image tag: $(cat $GITHUB_OUTPUT | sed -n 's/^tag=//p')"

      # PLAN / APPLY / DESTROY
      - name: Terraform Plan
        if: ${{ needs.pick.outputs.action == 'plan' }}
        run: |
          terraform plan -lock-timeout=60s -parallelism=7 -no-color -input=false \
            -var="environment=${{ needs.pick.outputs.env }}" \
            -var="aws_region=${{ needs.pick.outputs.region }}" \
            -var="namespace=${{ needs.pick.outputs.namespace }}" \
            -var="image_tag=${{ steps.img.outputs.tag }}" \
            -var="aws_access_key_id=${{ steps.awscreds.outputs.aki }}" \
            -var="aws_secret_access_key=${{ steps.awscreds.outputs.sak }}" \
            -out="tfplan-${{ needs.pick.outputs.env }}"

      - name: Terraform Apply
        if: ${{ needs.pick.outputs.action == 'apply' }}
        run: |
          set -euo pipefail
          terraform plan -lock-timeout=60s -parallelism=7 -no-color -input=false \
            -var="environment=${{ needs.pick.outputs.env }}" \
            -var="aws_region=${{ needs.pick.outputs.region }}" \
            -var="namespace=${{ needs.pick.outputs.namespace }}" \
            -var="image_tag=${{ steps.img.outputs.tag }}" \
            -var="aws_access_key_id=${{ steps.awscreds.outputs.aki }}" \
            -var="aws_secret_access_key=${{ steps.awscreds.outputs.sak }}" \
            -out="tfplan-${{ needs.pick.outputs.env }}"
          terraform apply -input=false -no-color "tfplan-${{ needs.pick.outputs.env }}"

      - name: Terraform Destroy
        if: ${{ needs.pick.outputs.action == 'destroy' }}
        run: |
          terraform destroy -auto-approve -input=false \
            -var="environment=${{ needs.pick.outputs.env }}" \
            -var="aws_region=${{ needs.pick.outputs.region }}" \
            -var="namespace=${{ needs.pick.outputs.namespace }}" \
            -var="image_tag=ignore" \
            -var="aws_access_key_id=${{ steps.awscreds.outputs.aki }}" \
            -var="aws_secret_access_key=${{ steps.awscreds.outputs.sak }}"

      # Show LB URL + health after APPLY
      - name: Show LB URL and health check
        if: ${{ needs.pick.outputs.action == 'apply' }}
        env:
          CLUSTER_NAME: ${{ inputs.cluster_name != '' && inputs.cluster_name || needs.pick.outputs.cluster_name }}
          REGION: ${{ needs.pick.outputs.region }}
          NAMESPACE: ${{ needs.pick.outputs.namespace }}
        run: |
          set -euo pipefail

          # Try to get LB from Terraform outputs (several common keys)
          LB_HOST=""
          for key in lb_hostname load_balancer_hostname service_hostname elb_hostname; do
            if terraform output -json "$key" >/dev/null 2>&1; then
              v=$(terraform output -raw "$key" 2>/dev/null || true)
              if [ -n "$v" ]; then LB_HOST="$v"; break; fi
            fi
          done

          # If still empty, try via Kubernetes service
          if [ -z "$LB_HOST" ]; then
            aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$REGION" >/dev/null
            # find LB hostname from Service of type LoadBalancer
            LB_HOST=$(kubectl -n "$NAMESPACE" get svc -o jsonpath='{range .items[?(@.spec.type=="LoadBalancer")]}{.status.loadBalancer.ingress[0].hostname}{"\n"}{end}' | head -n1)
          fi

          if [ -z "$LB_HOST" ]; then
            echo "LB hostname not found."
            exit 0
          fi

          echo "LB hostname: $LB_HOST"
          echo "Health check:"
          set +e
          curl -fsS --max-time 5 "http://${LB_HOST}:1111/healthz" || true
          echo
          curl -fsS --max-time 5 "http://${LB_HOST}:1111/readyz" || true
          echo
