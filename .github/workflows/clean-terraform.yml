name: Guest List Clean Terraform (Deploy)

on:
  push:
    branches: [ main ]            # auto on main only
  workflow_dispatch:              # manual everywhere
    inputs:
      action:
        type: choice
        description: plan / apply / destroy
        default: plan
        options: [plan, apply, destroy]
      env:
        type: choice
        description: Choose environment
        default: dev
        options: [dev, staging, main, sivan, dvir, sahar, gili]
      branch:
        description: Branch to run on (blank = current)
        required: false
        default: ""
      image_tag:
        description: Docker image tag override (blank = auto)
        required: false
        default: ""

env:
  TF_VERSION: 1.9.8
  TF_CLI_ARGS: -no-color
  AWS_REGION: us-east-1

jobs:
  pick:
    runs-on: ubuntu-latest
    outputs:
      env: ${{ steps.pick.outputs.env }}
      branch: ${{ steps.pick.outputs.branch }}
      action: ${{ steps.pick.outputs.action }}
      image_tag: ${{ steps.pick.outputs.image_tag }}
      state_bucket: ${{ steps.pick.outputs.state_bucket }}
      state_key: ${{ steps.pick.outputs.state_key }}
    steps:
      - id: pick
        shell: bash
        run: |
          set -euo pipefail
          ACTION="${{ github.event_name == 'workflow_dispatch' && inputs.action != '' && inputs.action || 'plan' }}"
          ENV_IN="${{ github.event_name == 'workflow_dispatch' && inputs.env    != '' && inputs.env    || 'dev'  }}"
          BRANCH_IN="${{ github.event_name == 'workflow_dispatch' && inputs.branch != '' && inputs.branch || '' }}"
          IMG_IN="${{ github.event_name == 'workflow_dispatch' && inputs.image_tag != '' && inputs.image_tag || '' }}"

          # branch to use
          if [ -n "$BRANCH_IN" ]; then
            BRANCH="$BRANCH_IN"
          else
            BRANCH="${GITHUB_REF_NAME}"
          fi

          ENV="$ENV_IN"

          case "$ENV" in
            sivan|dvir|sahar|gili)
              BUCKET="guestlist-tfstate-${ENV}-feature"
              [ -z "$IMG_IN" ] && IMG="${ENV}-feature" || IMG="$IMG_IN"
              ;;
            dev|staging|main)
              BUCKET="guestlist-tfstate-${ENV}"
              [ -z "$IMG_IN" ] && IMG="latest" || IMG="$IMG_IN"
              ;;
            *)
              echo "::error::Unsupported env '$ENV'"; exit 1
              ;;
          esac

          KEY="envs/${ENV}/terraform.tfstate"

          echo "env=$ENV" >> "$GITHUB_OUTPUT"
          echo "branch=$BRANCH" >> "$GITHUB_OUTPUT"
          echo "action=$ACTION" >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMG" >> "$GITHUB_OUTPUT"
          echo "state_bucket=$BUCKET" >> "$GITHUB_OUTPUT"
          echo "state_key=$KEY" >> "$GITHUB_OUTPUT"

  tf:
    needs: pick
    runs-on: ubuntu-latest
    # Keep GH Environment scoping matching the selected env (as before)
    environment: ${{ needs.pick.outputs.env }}
    env:
      # Avoid parser issues: set literal here instead of using ${{ env.* }} expressions
      AWS_REGION: us-east-1
      ENVIRONMENT: ${{ needs.pick.outputs.env }}
      TF_STATE_BUCKET: ${{ needs.pick.outputs.state_bucket }}
      TF_STATE_KEY: ${{ needs.pick.outputs.state_key }}
      IMAGE_TAG: ${{ needs.pick.outputs.image_tag }}
      NAMESPACE: guestlist
      STUDENT_NAME: ${{ needs.pick.outputs.env }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.pick.outputs.branch }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Use literal to dodge the earlier parser complaint
          aws-region: us-east-1
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Ensure backend (S3 & DynamoDB)
        shell: bash
        run: |
          set -euo pipefail
          BKT="${TF_STATE_BUCKET}"
          TBL="terraform-locks"

          if ! aws s3api head-bucket --bucket "$BKT" 2>/dev/null; then
            if [ "${AWS_REGION}" = "us-east-1" ]; then
              aws s3api create-bucket --bucket "$BKT" || true
            else
              aws s3api create-bucket --bucket "$BKT" --region "${AWS_REGION}" \
                --create-bucket-configuration LocationConstraint="${AWS_REGION}" || true
            fi
          fi
          aws s3api put-bucket-versioning --bucket "$BKT" --versioning-configuration Status=Enabled || true
          aws s3api put-bucket-encryption --bucket "$BKT" \
            --server-side-encryption-configuration '{"Rules":[{"ApplyServerSideEncryptionByDefault":{"SSEAlgorithm":"AES256"}}]}' || true

          if ! aws dynamodb describe-table --table-name "$TBL" >/dev/null 2>&1; then
            aws dynamodb create-table \
              --table-name "$TBL" \
              --attribute-definitions AttributeName=LockID,AttributeType=S \
              --key-schema AttributeName=LockID,KeyType=HASH \
              --billing-mode PAY_PER_REQUEST
            aws dynamodb wait table-exists --table-name "$TBL"
          fi

      - name: Terraform init
        shell: bash
        run: |
          set -euo pipefail
          terraform init -input=false -reconfigure \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${AWS_REGION}" \
            -backend-config="dynamodb_table=terraform-locks"

      - name: Terraform Plan
        if: ${{ needs.pick.outputs.action == 'plan' }}
        shell: bash
        run: |
          set -euo pipefail
          terraform plan -lock-timeout=60s -parallelism=7 -input=false \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=${IMAGE_TAG}" \
            -var="student_name=${STUDENT_NAME}" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -out="tfplan-${ENVIRONMENT}"

      - name: Terraform Apply
        if: ${{ needs.pick.outputs.action == 'apply' }}
        shell: bash
        run: |
          set -euo pipefail
          terraform plan -lock-timeout=60s -parallelism=7 -input=false \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=${IMAGE_TAG}" \
            -var="student_name=${STUDENT_NAME}" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -out="tfplan-${ENVIRONMENT}"
          terraform apply -input=false -auto-approve "tfplan-${ENVIRONMENT}"

      - name: Show LB URL and health
        if: ${{ needs.pick.outputs.action == 'apply' }}
        shell: bash
        run: |
          set -euo pipefail
          CN="$(terraform output -raw cluster_name 2>/dev/null || true)"
          [ -z "$CN" ] && CN="guestlist-cluster"
          aws eks update-kubeconfig --name "$CN" --region "${AWS_REGION}"

          SVC_HOST="$(kubectl -n ${NAMESPACE} get svc -l app=guestlist-api -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null || true)"
          echo "LoadBalancer: ${SVC_HOST}"
          for p in /readyz /healthz /; do
            echo "--- curl http://${SVC_HOST}${p}"
            (curl -fsS "http://${SVC_HOST}${p}" || true)
            echo
          done

      - name: Terraform Destroy
        if: ${{ needs.pick.outputs.action == 'destroy' }}
        shell: bash
        run: |
          set -euo pipefail
          terraform destroy -input=false -auto-approve \
            -var="environment=${ENVIRONMENT}" \
            -var="aws_region=${AWS_REGION}" \
            -var="namespace=${NAMESPACE}" \
            -var="image_tag=ignore" \
            -var="student_name=${STUDENT_NAME}" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}"